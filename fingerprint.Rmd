---
title: "R Notebook"
output: html_notebook
---
initialize data:

```{r}
library(topGO)
library(readxl)
library(dplyr)
library(hablar)
library(naniar)
library(stringr)
library(ggplot2)
library(org.Hs.eg.db)
library(gridExtra)
library(Rgraphviz)
library(GO.db)
library(foreach)
library(doParallel)

# data prep:
sData = read_excel("sData.xlsx")
sData = sData %>%
  convert(dbl(np,
              nq,
              nfc,
              cp,
              cq,
              cfc,
              polyICp,
              polyICq,
              polyICFC,
              polyICFCB,
))

sData = sData %>%
  filter(conf == "High conf")
sData %>%
  replace_with_na(replace = list(x = c("na", "ns")))

sData$UniprotID = str_replace_all(sData$UniprotID, "-[0-9]*", "")

# each bait is populated with its preys:
baits = unique(sData$Bait)
geneNames = vector("list", length=length(baits))
names(geneNames) = baits

for (i in 1:length(baits)) {
  rows = sData %>% filter(Bait == baits[i])
  geneNames[[i]] = rows$UniprotID
}

#CORUM data prep:
corumData = read.delim2("./CORUM.txt", sep="\t", stringsAsFactors = FALSE)

#GO data prep:
gene2GO = readMappings(file="./gene2GO.map")
gene2GOdf = read.csv2("./gene2GOdf.csv", stringsAsFactors = FALSE)

#Enriched genes associated to GO term and its bait
genesOfTerm = data.frame()

#Graph containing the dotlist strings
graphsBP = vector("list", length=length(baits))
graphsCC = vector("list", length=length(baits))
names(graphsCC) = baits
names(graphsBP) = baits

#List containing CC piechart data
ccList = vector("list", length=length(baits))
names(ccList) = baits

#Tot parents and children for different GO terms
CCparents = as.list(GOCCPARENTS)
CCancestors = as.list(GOCCANCESTOR)
CCoffspring = as.list(GOCCOFFSPRING)
BPparents = as.list(GOBPPARENTS)
BPoffspring = as.list(GOBPOFFSPRING)

GO = ""
```


Generating GOBP and GOCC:

```{r message=FALSE, include=FALSE}
enrichGOterms = function(bait, ont) {
  minNumberOfGenesPerTerms = 5
  myInterestingGenes = geneNames[[bait]]
  print(c("number of genes for selected bait", length(myInterestingGenes)))
  dataGeneNames = unique(sData$UniprotID)
  geneList = factor(as.integer(dataGeneNames %in% myInterestingGenes))
  names(geneList) = dataGeneNames
  
  GOdataBP = new("topGOdata",
    description="topGO object for a given bait",
    ontology=ont,
    allGenes = geneList,
    nodeSize= minNumberOfGenesPerTerms,
    annot= annFUN.gene2GO,
    gene2GO = gene2GO
  )
  #GO <<- buildLevels(GOdataBP)
  # weight01FisherResult = runTest(GOdataBP, statistic = "fisher") # default algorithm = weight01
  
  # add graph to the list of graphs
  # dag = showSigOfNodes(GOdataBP, score(weight01FisherResult), useFullNames = TRUE, firstSigNodes = 5, useInfo = "all")
  # dotFile = tempfile()
  # toFile(dag$complete.dag, filename = dotFile)
  # dotStr = readLines(dotFile)
  # if (ont == "BP") {
  #   graphsBP[[bait]] <<- dotStr
  # } else {
  #   graphsCC[[bait]] <<- dotStr
  # }
  # unlink(dotFile)
  
  #generate piechart data if cc ont
  
  # allRes = GenTable(
  #   GOdataBP,
  #   weight = weight01FisherResult,
  #   topNodes = 20,
  #   orderBy="weight"
  # )
  if (ont == "CC") {#generate the data for the pie chart
    LCA(allRes$GO.ID)
  }
  # filterGenes(allRes$GO.ID, ont, bait, GOdataBP, myInterestingGenes)
  # return(allRes)
}
```

Generate data for the piechart depicting dynamically obtained relevant CC terms. From the perspective of the CC tree, we get the list of ancestors for each terms and we look for the Last Common Ancestor (LCA). It encompasses terms far away in the hierarchy. 
For terms at the top of the tree, they will have the most terms included. Those terms are filtered out simply because they have the higher number of children.
```{r}
LCA = function(GOids) {
  CCparentsDf = data.frame()
  for (i in 1:length(GOids)) {
    goID = GOids[i]
    parents = CCancestors[[goID]]
    pLastInd = match("all", parents)
    parents = parents[-pLastInd]
    df = data.frame(
      goID = goID,
      parent = parents,
      stringsAsFactors = F
    )
    CCparentsDf = rbind(CCparentsDf,df)
  }
}
```

```{r eval=FALSE}
enrichGOterms("NSP3", "CC")
```
filtered genes has to be without ancestor redondencies, associated to GO term but more importantly to the bait because this information will be used for interaction verification experience. Drug design can be done only with the most important genes of associated functions, the bait is not interesting for this purpose.
GeneRange contains the list of genes that the search should be limit to because gene2GOdf contains every genes of each terms. Filtered genes based only on GOID therefore doesn't make any sense without a restricted set of genes of reference (myInterestingGenes)
```{r}
genesOfTerm = data.frame(stringsAsFactors = FALSE)
filterGenes = function(GOids, ont, bait, goData, geneRange) {
  
  if (ont == "CC") {
    totAncestors = CCparents
    totOffspring = CCoffspring
  } else {
    totAncestors = BPparents
    totOffspring = BPoffspring
  }
  for(i in 1:length(GOids)) {
    goTerm = GOids[i]
    annotatedGenesInGoTerm = genesInTerm(goData, goTerm)[[1]]
    sigGenesInTerm = annotatedGenesInGoTerm[annotatedGenesInGoTerm %in% geneRange]
    
    ## FIND UNIQUE GENES IN TERM
    genesInGoTerm = gene2GOdf[which(
      gene2GOdf$goID == goTerm &
        gene2GOdf$uniprotID %in% sigGenesInTerm
    ), "uniprotID"]
    
    ## FIND REDENDANCIES IN ANCESTORS AND CHILDREN
    ancestors = unname(totAncestors[[goTerm]])
    offspring = unname(totOffspring[[goTerm]])
    
    offspringGenes = gene2GOdf[which(
      gene2GOdf$goID %in% offspring &
        gene2GOdf$uniprotID %in% sigGenesInTerm
    ), "uniprotID"]
    
    ancestorsGenes = gene2GOdf[which(
      gene2GOdf$goID %in% ancestors &
        gene2GOdf$uniprotID %in% sigGenesInTerm
    ), "uniprotID"]
    ancestorsGenes = unique(ancestorsGenes)
    
    for(j in 1:length(sigGenesInTerm)) {
      gene = sigGenesInTerm[j]
      str = ""
      if (gene %in% offspringGenes) {
        str = paste(str, "offspring", sep = "|")
      }
      if (gene %in% ancestorsGenes) {
        str = paste(str, "ancestor", sep = "|")
      }
      if (gene %in% genesInGoTerm) {
        str = paste(str, "inTerm", sep = "|")
      }
      geneSymbol = sData[which(sData$UniprotID == gene),"GeneName"]
      genesOfTerm <<- rbind(genesOfTerm, data.frame(
        stringsAsFactors = FALSE,
        goID = goTerm,
        uniprotID = gene,
        geneSymbol = geneSymbol[1,"GeneName"],
        uniqueness = str
      ))
    }
  }
}
```

Generating CORUM protein complex ordering:

```{r}
enrichPC = function(bait) {
  preys = geneNames[[bait]]
  preyLength = length(preys)
  CORUMdf = data.frame(
    Prey=character(0), Complex=character(0), stringsAsFactors = FALSE)

  for(i in 1:preyLength) {
    prey = preys[i]
    #print(prey)
    complexes = corumData[which(str_detect(corumData$subunits.UniProt.IDs., prey)),"ComplexID"]
    #print(length(complexes))
    if (length(complexes) == 0) {
      CORUMdf[nrow(CORUMdf)+1, c("Prey", "Complex")] = c(prey,NA)
    } else {
      for(j in 1:length(complexes)) {
        CORUMdf[nrow(CORUMdf)+1, c("Prey", "Complex")] = c(prey,complexes[j])
      }
    }
  }
  
  # make the occurence count table with added columns of interest as the presentation table. 
  idCounts = as.data.frame(table(CORUMdf$Complex), stringsAsFactors = FALSE)
  if(nrow(idCounts) > 0) {
    names(idCounts) = c("id", "occurences")
    #returnedTable = merge(x=corumData, y=idCounts, by.y="id", by.x="ComplexID", all.y=TRUE)
    #idCounts = idCounts[which(idCounts$occurences>=2),]
    CORUMdf = merge(x=CORUMdf, y=idCounts, by.y="id", by.x="Complex", all.y=TRUE)
    returnedTable = merge(x=corumData, y=CORUMdf, by.y="Complex", by.x="ComplexID", all.y=TRUE)
  } else {
    returnedTable = data.frame(
      ComplexName = NA,
      occurences = NA,
      ComplexID = NA,
      stringsAsFactors = FALSE
    )
  }
  return(returnedTable)
}
```

```{r eval=FALSE}
#BPterms = enrichGOterms("NSP6", "BP") # enrich biological processes
#CCterms = enrichGOterms("NSP6", "CC") # enrich cellular locations
PCterms = enrichPC("M") # enrich protein complexes
print(PCterms)
```

generate enriched data:
```{r}
enrichedGOdata = data.frame()
enrichedPCdata = data.frame()

for(i in 1:3) {
  BPterms = enrichGOterms(baits[i], "BP") # enrich biological processes
  CCterms = enrichGOterms(baits[i], "CC") # enrich cellular locations
  PCterms = enrichPC(baits[i]) # enrich protein complexes
  
  PCgeneName = data.frame()
  for (j in 1:nrow(PCterms)) {
    val = unique(sData[which(sData$UniprotID == PCterms[j, "Prey"]),"GeneName"])
    PCgeneName = rbind(PCgeneName, data.frame(val))
  }
  
  CCdf = data.frame(
    bait=baits[i],
    goID = CCterms$GO.ID,
    term = Term(CCterms$GO.ID),
    ont = "CC",
    score = CCterms$weight,
    stringsAsFactors = FALSE)
  BPdf = data.frame(
    bait=baits[i],
    goID=BPterms$GO.ID,
    term = Term(BPterms$GO.ID),
    ont = "BP",
    score = BPterms$weight,
    stringsAsFactors = FALSE)
  PCdf = data.frame(
    bait=baits[i], 
    pcID=PCterms$ComplexID, 
    pcCount=PCterms$occurences,
    complexName = PCterms$ComplexName,
    geneName = PCgeneName$GeneName,
    uniprotID = PCterms$Prey,
    stringsAsFactors = FALSE)

  enrichedGOdata = rbind(enrichedGOdata, CCdf, BPdf)
  enrichedPCdata = rbind(enrichedPCdata, PCdf)
}
```

work with enriched data:
Here the list of enriched terms will be cleared of redundancy between CC terms.
```{r}
#remove GO redundencies
superEnrichedGOdata = data.frame()
for(i in 1:28) {
  bait = baits[i]
  
  baitGOensembl = enrichedGOdata[which(enrichedGOdata$bait == bait),]
  substrGOensembl = enrichedGOdata[which(enrichedGOdata$bait != bait),]
  
  intersectGO = na.omit(intersect(baitGOensembl$goID, substrGOensembl$goID))
  
  for(j in 1:length(intersectGO)) {
    ind = which(
        baitGOensembl$goID == intersectGO[j]
      ) 
    baitGOensembl = baitGOensembl[-ind,]
  }

  superEnrichedGOdata = rbind(superEnrichedGOdata, baitGOensembl)
  
  #remove useless entries from graphs
  
}
#PC enrichment? not for now
```
Enriching GO and PC genes:

```{r}
#enrich GO and PC genes
duplicatesInEnrichedGOgenes = which(duplicated(genesOfTerm$uniprotID) & 
  genesOfTerm$goID %in% superEnrichedGOdata$goID
)
duplicatesInEnrichedPCgenes = which(duplicated(enrichedPCdata$uniprotID))

GOduplicates = genesOfTerm[duplicatesInEnrichedGOgenes, "uniprotID"]
PCduplicates = enrichedPCdata[duplicatesInEnrichedPCgenes, "uniprotID"]

for (i in 1:nrow(genesOfTerm)) { #for genes of GO
  if (genesOfTerm[i, "uniprotID"] %in% GOduplicates) {
    genesOfTerm[i, "uniqueness"] = paste(genesOfTerm[i, "uniqueness"], "duplicated", sep="|")
  }
}
for (i in 1:nrow(enrichedPCdata)) { #for genes of PC
  if (enrichedPCdata[i, "uniprotID"] %in% PCduplicates) {
    enrichedPCdata[i, "uniqueness"] = "duplicated"
  } else {
    enrichedPCdata[i, "uniqueness"] = "unique"
  }
}
```

generate data for the piechart:
```{r}

```