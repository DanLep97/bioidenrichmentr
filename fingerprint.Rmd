---
title: "R Notebook"
output: html_notebook
---
initialize data:

```{r}
library(topGO)
library(readxl)
library(dplyr)
library(hablar)
library(naniar)
library(stringr)
library(ggplot2)
library(org.Hs.eg.db)
library(gridExtra)
library(Rgraphviz)
library(GO.db)
library(foreach)
library(doParallel)

# data prep:
sData = read_excel("sData.xlsx")
sData = sData %>%
  convert(dbl(np,
              nq,
              nfc,
              cp,
              cq,
              cfc,
              polyICp,
              polyICq,
              polyICFC,
              polyICFCB,
))

sData = sData %>%
  filter(conf == "High conf")
sData %>%
  replace_with_na(replace = list(x = c("na", "ns")))

sData$UniprotID = str_replace_all(sData$UniprotID, "-[0-9]*", "")

# each bait is populated with its preys:
baits = unique(sData$Bait)
geneNames = vector("list", length=length(baits))
names(geneNames) = baits

for (i in 1:length(baits)) {
  rows = sData %>% filter(Bait == baits[i])
  geneNames[[i]] = rows$UniprotID
}

#CORUM data prep:
corumData = read.delim2("./CORUM.txt", sep="\t", stringsAsFactors = FALSE)

#GO data prep:
gene2GO = readMappings(file="./gene2GO.map")
gene2GOdf = read.csv2("./gene2GOdf.csv", stringsAsFactors = FALSE)

#Enriched genes associated to GO term and its bait
genesOfTerm = data.frame()

#Graph containing the dotlist strings
graphs = vector("list", length=length(baits))
names(graphs) = baits

#List containing CC piechart data
ccList = vector("list", length=length(baits))
names(ccList) = baits
```


Generating GOBP and GOCC:

```{r message=FALSE, include=FALSE}
enrichGOterms = function(bait, ont) {
  minNumberOfGenesPerTerms = 5
  myInterestingGenes = geneNames[[bait]]
  print(c("number of genes for selected bait", length(myInterestingGenes)))
  dataGeneNames = unique(sData$UniprotID)
  geneList = factor(as.integer(dataGeneNames %in% myInterestingGenes))
  names(geneList) = dataGeneNames
  
  GOdataBP = new("topGOdata",
    description="topGO object for a given bait",
    ontology=ont,
    allGenes = geneList,
    nodeSize= minNumberOfGenesPerTerms,
    annot= annFUN.gene2GO,
    gene2GO = gene2GO
  )
  weight01FisherResult = runTest(GOdataBP, statistic = "fisher") # default algorithm = weight01
  
  #add graph to the list of graphs
  if (ont == "BP") {
    dag = showSigOfNodes(GOdataBP, score(weight01FisherResult), firstSigNodes = 5, useInfo = "all")
    dotFile = tempfile()
    toFile(dag$complete.dag, filename = dotFile)
    dotStr = readLines(dotFile)
    graphs[[bait]] <<- dotStr
    unlink(dotFile)
  }
  
  allRes = GenTable(
    GOdataBP,
    weight = weight01FisherResult,
    topNodes = 20,
    orderBy="weight"
  )
  print(allRes)
  filterGenes(allRes$GO.ID, ont, bait, GOdataBP, myInterestingGenes)
  return(allRes)
}
```
filtered genes has to be without ancestor redondencies, associated to GO term but more importantly to the bait because this information will be used for interaction verification experience. Drug design can be done only with the most important genes of associated functions, the bait is not interesting for this purpose.
GeneRange contains the list of genes that the search should be limit to because gene2GOdf contains every genes of each terms. Filtered genes based only on GOID therefore doesn't make any sense without a restricted set of genes of reference (myInterestingGenes)
```{r}
genesOfTerm = data.frame(stringsAsFactors = FALSE)
filterGenes = function(GOids, ont, bait, goData, geneRange) {
  
  if (ont == "CC") {
    totAncestors = as.list(GOCCPARENTS)
    totOffspring = as.list(GOCCOFFSPRING)
  } else {
    totAncestors = as.list(GOBPPARENTS)
    totOffspring = as.list(GOBPOFFSPRING)
  }
  for(i in 1:length(GOids)) {
    goTerm = GOids[i]
    annotatedGenesInGoTerm = genesInTerm(goData, goTerm)[[1]]
    sigGenesInTerm = annotatedGenesInGoTerm[annotatedGenesInGoTerm %in% geneRange]
    
    ## FIND UNIQUE GENES IN TERM
    genesInGoTerm = gene2GOdf[which(
      gene2GOdf$goID == goTerm &
        gene2GOdf$uniprotID %in% sigGenesInTerm
    ), "uniprotID"]
    
    ## FIND REDENDANCIES IN ANCESTORS AND CHILDREN
    ancestors = unname(totAncestors[[goTerm]])
    offspring = unname(totOffspring[[goTerm]])
    
    offspringGenes = gene2GOdf[which(
      gene2GOdf$goID %in% offspring &
        gene2GOdf$uniprotID %in% sigGenesInTerm
    ), "uniprotID"]
    
    ancestorsGenes = gene2GOdf[which(
      gene2GOdf$goID %in% ancestors &
        gene2GOdf$uniprotID %in% sigGenesInTerm
    ), "uniprotID"]
    ancestorsGenes = unique(ancestorsGenes)
    
    for(j in 1:length(sigGenesInTerm)) {
      gene = sigGenesInTerm[j]
      str = ""
      if (gene %in% offspringGenes) {
        str = paste(str, "offspring", sep = "|")
      }
      if (gene %in% ancestorsGenes) {
        str = paste(str, "ancestor", sep = "|")
      }
      if (gene %in% genesInGoTerm) {
        str = paste(str, "inTerm", sep = "|")
      }
      geneSymbol = sData[which(sData$UniprotID == gene),"GeneName"]
      genesOfTerm <<- rbind(genesOfTerm, data.frame(
        stringsAsFactors = FALSE,
        goID = goTerm,
        uniprotID = gene,
        geneSymbol = geneSymbol[1,"GeneName"],
        uniqueness = str
      ))
    }
  }
}
```


```{r eval=FALSE}
enrichGOterms("NSP3", "CC")
```


Generating CORUM protein complex ordering:

```{r}
enrichPC = function(bait) {
  preys = geneNames[[bait]]
  preyLength = length(preys)
  CORUMdf = data.frame(
    Prey=character(0), Complex=character(0), stringsAsFactors = FALSE)

  for(i in 1:preyLength) {
    prey = preys[i]
    #print(prey)
    complexes = corumData[which(str_detect(corumData$subunits.UniProt.IDs., prey)),"ComplexID"]
    #print(length(complexes))
    if (length(complexes) == 0) {
      CORUMdf[nrow(CORUMdf)+1, c("Prey", "Complex")] = c(prey,NA)
    } else {
      for(j in 1:length(complexes)) {
        CORUMdf[nrow(CORUMdf)+1, c("Prey", "Complex")] = c(prey,complexes[j])
      }
    }
  }
  
  # make the occurence count table with added columns of interest as the presentation table. 
  idCounts = as.data.frame(table(CORUMdf$Complex), stringsAsFactors = FALSE)
if(nrow(idCounts) > 0) {
  names(idCounts) = c("id", "occurences")
  #returnedTable = merge(x=corumData, y=idCounts, by.y="id", by.x="ComplexID", all.y=TRUE)
  #idCounts = idCounts[which(idCounts$occurences>=2),]
  CORUMdf = merge(x=CORUMdf, y=idCounts, by.y="id", by.x="Complex", all.y=TRUE)
  returnedTable = merge(x=corumData, y=CORUMdf, by.y="Complex", by.x="ComplexID", all.y=TRUE)
} else {
  returnedTable = data.frame(
    ComplexName = NA,
    occurences = NA,
    ComplexID = NA,
    stringsAsFactors = FALSE
  )
  return(returnedTable)
  }
}
```

```{r eval=FALSE}
#BPterms = enrichGOterms("NSP6", "BP") # enrich biological processes
#CCterms = enrichGOterms("NSP6", "CC") # enrich cellular locations
PCterms = enrichPC("Orf6") # enrich protein complexes
print(PCterms)
```

generate enriched data:
```{r include=FALSE}
enrichedGOdata = data.frame(
    bait = character(0),
    goID = character(0),
    term = character(0),
    ont = character(0),
    score = character(0),
    stringsAsFactors = FALSE
  )
enrichedPCdata = data.frame(
  bait = character(0),
  pcID = character(0),
  pcCount = integer(0),
  complexName = character(0),
  uniprotID = character(0),
  stringsAsFactors = FALSE
)

for(i in 1:28) {
  BPterms = enrichGOterms(baits[i], "BP") # enrich biological processes
  CCterms = enrichGOterms(baits[i], "CC") # enrich cellular locations
  PCterms = enrichPC(baits[i]) # enrich protein complexes
  
  CCdf = data.frame(
    bait=baits[i], 
    goID = CCterms$GO.ID, 
    term = Term(CCterms$GO.ID),
    ont = "CC",
    score = CCterms$weight,
    stringsAsFactors = FALSE)
  BPdf = data.frame(
    bait=baits[i], 
    goID=BPterms$GO.ID, 
    term = Term(BPterms$GO.ID),
    ont = "BP",
    score = BPterms$weight,
    stringsAsFactors = FALSE)
  PCdf = data.frame(
    bait=baits[i], 
    pcID=PCterms$ComplexID, 
    pcCount=PCterms$occurences,
    complexName = PCterms$ComplexName,
    uniprotID = PCterms$Prey,
    stringsAsFactors = FALSE)

  enrichedGOdata = rbind(enrichedGOdata, CCdf, BPdf)
  enrichedPCdata = rbind(enrichedPCdata, PCdf)
}
```

work with enriched data:
Here the list of enriched terms will be cleared of redundancy between CC terms.
```{r}
#remove GO redundencies
superEnrichedGOdata = data.frame()
for(i in 1:28) {
  bait = baits[i]
  
  baitGOensembl = enrichedGOdata[which(enrichedGOdata$bait == bait),]
  substrGOensembl = enrichedGOdata[which(enrichedGOdata$bait != bait),]
  
  intersectGO = na.omit(intersect(baitGOensembl$goID, substrGOensembl$goID))
  
  for(j in 1:length(intersectGO)) {
    ind = which(
        baitGOensembl$goID == intersectGO[j]
      ) 
    baitGOensembl = baitGOensembl[-ind,]
  }

  superEnrichedGOdata = rbind(superEnrichedGOdata, baitGOensembl)
}
#PC enrichment? not for now
```
Enriching genes:

```{r}
duplicatesInEnrichedGenes = which(duplicated(genesOfTerm$uniprotID) & 
  genesOfTerm$goID %in% superEnrichedGOdata$goID
)
duplicates = genesOfTerm[duplicatesInEnrichedGenes, "uniprotID"]
print(length(duplicates))
for (i in 1:nrow(genesOfTerm)) {
  if (genesOfTerm[i, "uniprotID"] %in% duplicates) {
    genesOfTerm[i, "uniqueness"] = paste(genesOfTerm[i, "uniqueness"], "duplicated", sep="|")
  }
}
```


```{r}
```